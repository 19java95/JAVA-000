## 【极客时间】课程https://time.geekbang.org/column/intro/100017501总结

### 关键点

1. 稳。整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期 时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基 本的前提。
2. 准。“准”就是要求保证数据的一致性。
3. 快。整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。

### 5个架构原则

1. 数据要尽量少
2. 请求数要尽量少
3. 路径要尽量短
4. 依赖尽量少
5. 不要有单点

### 动静数据分离与方案

动态数据指与URL、浏览者、时间、地域相关，以及是否含有 Cookie 等有关的私密数据，静态数据与上述无关

1. 把静态数据缓存到离用户最近的地方
2. 直接缓存 HTTP 连接而不是仅仅缓存数据（静态化改造）
3. Web 服务器更擅长缓存静态数据

如何做动静分离改造

静态数据如何处理

1. URL 唯一化，这样可以直接缓存 HTTP 连接
2. 分离浏览者相关的因素
3. 分离时间因素
4. 异步化地域因素
5. 去掉 Cookie，在缓存静态数据中不含有Cookie

动态数据如何处理

1. 在 Web 代理服务器上做动态内容请求，并将请求插入到静态 页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影 响，但是用户体验较好。
2. 单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。

### 热点数据发现与处理

发现静态热点数据，卖家发现，自己统计，但这样时效性不高。

发现动态热点数据，通过实施日志数据，分析这些日志数据，并反馈给后台。

处理热点数据通常有几种思路:一是优化，二是限制，三是隔离

### 流量削峰

削峰的存在，一 是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本。

**排队**，中间加一层，用作缓冲队列

**分层过滤**，在不同的层次尽可能地过滤掉无效请求

### 减库存逻辑设计

#### 下单减库存

当用户并发请求到达服务端时，首先创建订单，然后扣除库存，等待用户支付。这种顺序是我们一般人首先会想到的解决方案，这种情况下也能保证订单不会超卖，因为创建订单之后就会减库存，这是一个原子操作。但是这样也会产生一些问题，第一就是在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的；第二是如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制IP和用户的购买订单数量，这也不算是一个好方法。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/2542319/1611582011669-e813879c-5c5e-45f8-b9d1-deaca8bfe38b.png)



####  支付减库存

如果等待用户支付了订单在减库存，第一感觉就是不会少卖。但是这是并发架构的大忌，因为在极限并发情况下，用户可能会创建很多订单，当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘IO

![image.png](https://cdn.nlark.com/yuque/0/2021/png/2542319/1611582018476-bc193bb9-2ed2-40e4-919d-5285a588e04c.png)

####  预扣库存

从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库IO。那么有没有一种不需要直接操作数据库IO的方案呢，这就是预扣库存。先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。订单的生成是异步的,一般都会放到MQ、kafka这样的即时消费队列中处理,订单量比较少的情况下，生成订单非常快，用户几乎不用排队。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/2542319/1611582040162-42adddf2-178c-4ad5-80cc-3913509b4a6c.png)

业务系统中最常见的就是预扣库存方案，买家下单后，库存为其保留一定的时间(如 10 分 钟)，超过这个时间，库存将会自动释放，在买家付款 前，系统会校验该订单的库存是否还有保留:如果没有保留，则再次尝试预扣;如果库存 不足(也就是预扣失败)则不允许继续付款;如果预扣成功，则完成付款并实际地减去库存。

秒杀商品采用“下单减库存”更加合

![image.png](https://cdn.nlark.com/yuque/0/2021/png/2542319/1611579574887-234633ab-f785-4d79-8fc1-6d54005e6110.png)

### 兜底方案

防刷、限量和防重。

防刷

限量

优惠券看作一种资源，其生产不是凭空的，而是需要事先申请														

防重															

第一，任何资金操作都需要在平台侧生成业务属性的订单，可以是优惠券发放订单，可以是 返现订单，也可以是借款订单，一定是先有订单再去做资金操作

第二，一定要做好防重，也就是实现幂等处理，并且幂等处理必须是全链路的

## github项目https://github.com/GuoZhaoran/spikeSystem总结

### 单机如何优化到高性能

服务器不仅要在本地减库存，另外要**远程统一减库存**。有了远程统一减库存的操作，我们就可以根据机器负载情况，为每台机器分配一些多余的“buffer库存”用来防止机器中有机器宕机的情况

![image.png](https://cdn.nlark.com/yuque/0/2021/png/2542319/1611582468642-f99ea26a-b3aa-4ee5-9e5c-738a9f7ca934.png)

采用Redis存储统一库存，因为Redis的性能非常高，号称单机QPS能抗10W的并发。在本地减库存以后，如果本地有订单，我们再去请求redis远程减库存，本地减库存和远程减库存都成功了，才返回给用户抢票成功的提示,这样也能有效的保证订单不会超卖。当机器中有机器宕机时，因为每个机器上有预留的buffer余票，所以宕机机器上的余票依然能够在其他机器上得到弥补，保证了不少卖。buffer余票设置多少合适呢，理论上buffer设置的越多，系统容忍宕机的机器数量就越多，但是buffer设置的太大也会对redis造成一定的影响。虽然redis内存数据库抗并发能力非常高，请求依然会走一次网络IO,其实抢票过程中对redis的请求次数是本地库存和buffer库存的总量，因为当本地库存不足时，系统直接返回用户“已售罄”的信息提示，就不会再走统一扣库存的逻辑，这在一定程度上也避免了巨大的网络请求量把redis压跨，所以buffer值设置多少，需要架构师对系统的负载能力做认真的考量。